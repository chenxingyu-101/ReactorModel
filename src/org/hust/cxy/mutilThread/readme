1、将单线程的反应器模式升级到多线程，最简单的方法是，直接在dispatch时，不管是acceptHandler还是IOhandler
都提交给线程池运行。这样导致的结果是，每个任务都要从线程池中掏出来一个线程。甚至于同一个连接的不同次事件都会触发拿出来一个
线程用。
2、我希望的是每个线程都有自己的选择器，来监听注册的IO事件,并进行处理。
3、但这样还并不够，子选择器的监听也会被任务耽误，应该是父选择器单独占一个线程。子选择器也单独占若干个线程。然后有任务就拿一个线程出来执行，
执行完毕再放回线程池。
4、但netty为了避免锁，一个channel始终被一个线程处理，现在关键的问题是netty的子选择器运行在这个线程上吗？
5、我先不像netty那样，我计划，父选择器占一个线程，开三个子线程监视子channel，父线程产生的子channel，随机注册到子监视器上。然后任务由线程池来执行。

经验：
1、先把子反应器线程跑起来，直接阻塞在selector.selector上了。这里不但子反应器线程阻塞了，它还持有了selector。这样我在父亲反应器里监听
到了连接，想把连接产生的channel注册到子反应器，都注册不了。所以子反应器线程在跑的时应该用selectNow()
2、为什么IOhandler可以和SubReactor分离:因为IOhandler只需要传入chanel就可以了，传入时是必定有可读事件的。
   而AcceptHandler和AcceptReactor不能分离，因为监视连接线程在启动的时候，我需要把监视IO事件的线程也启动了，启动IO就需要子反应器。
   AcceptHandler需要把连接分配到子反应器里面，如果分离了，就需要向其传四个参数（serverChannel和三个子反应器）
   如果后期考虑cpu核数来建立子反应器线程，就要把子反应器作为数组。这里只要向AcceptHandler传数组和serverChannel就行了。可以考虑分离开。
3、对经验1的优化：
    selectNow()虽然可以保证子反应器不会被子反应器线程一直持有。但是子反应器线程一直在空跑，占用cpu。
    经验1的冲突是想向子反应器注册新通道，注册不了。我注册前唤醒下不就行了吗？
    而且注册是个“很少发生的事情”,IO事件才是多发生的事情。故阻塞掉没有IO事件的线程是值得的。
问题：
1、为啥远程主机关闭连接了，服务端要说它强制关闭了连接，又办法优雅关闭吗？